<?php

// Контракт `UserRepositoryInterface` определяет набор методов, 
// которые должен реализовать репозиторий пользователей. 
// Это обеспечивает стандартизацию и гарантирует, 
// что любой репозиторий пользователей предоставит 
// одинаковый интерфейс для работы с пользовательскими данными.


// Вот пример того, как может выглядеть такой контракт:




namespace App\Repositories\Contracts;

use App\Models\User;

interface UserRepositoryInterface
{
    /**
     * Найти пользователя по идентификатору.
     *
     * @param int $id Идентификатор пользователя.
     * @return User|null Возвращает пользователя или null, если ничего не найдено.
     */
    public function find(int $id): ?User;

    /**
     * Получить пользователя по email.
     *
     * @param string $email Email пользователя.
     * @return User|null Возвращает пользователя или null, если ничего не найдено.
     */
    public function findByEmail(string $email): ?User;

    /**
     * Создать нового пользователя с заданными атрибутами.
     *
     * @param array $attributes Атрибуты для создания пользователя.
     * @return User Созданный пользователь.
     */
    public function create(array $attributes): User;

    // Могут быть и другие методы, например, обновление или удаление пользователей:
    /*
    public function update(int $id, array $attributes): bool;
    public function delete(int $id): bool;
    */

    // Здесь также могут быть методы для проверки существования пользователя, 
    // получения списка пользователей, в том числе с фильтрами и пагинацией, и т.д.
}



// Теперь любой класс, который будет реализовывать `UserRepositoryInterface`, 
// должен будет реализовать методы `find`, `findByEmail` и `create`. 
// Это обеспечивает возможность подмены реализации репозитория 
// без внесения изменений в другие части системы, т.к. весь код будет зависеть от абстракции (интерфейса), 
// а не от конкретной реализации. Это позволяет достичь принципа инверсии зависимостей 
// (Dependency Inversion Principle), одного из принципов SOLID.